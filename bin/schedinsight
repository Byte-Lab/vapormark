#!/usr/bin/env python3
import os
import sys
import argparse
import csv
import matplotlib.pyplot as plt
import zlib
import collections


def hash_rgb_from_str(s):
    h = zlib.crc32( bytes(s, 'utf-8') )
    r = (h & 0x00FF00) >> 8
    g = (h & 0xFF0000) >> 16
    b = (h & 0x0000FF) >> 0
    return (float(r)/0xFF, float(g)/0xFF, float(b)/0xFF)

class ev_type:
    SCHED = 0
    IDLE  = 1
    MIG   = 2
    AWAKE = 3

class ev_time:
    time   = 0.0 
    cpu_id = 0

    def __init__(self, t, c):
        self.time = t
        self.cpu_id = c

    def __repr__(self):
        return "\t".join(["%.6f" % self.time, "[%d]" % self.cpu_id])

class ev_task:
    # per-class variables
    task_dict = {} 

    # per-instanace variables
    task_name = ""
    task_id   = 0
    parent_id = 0
    color = (0.0, 0.0, 0.0)

    @classmethod
    def get_instance(cls, tname, tid, pid):
        key = '^'.join([tname, str(tid), str(pid)])
        inst = cls.task_dict.get(key)
        if inst == None: 
            inst = cls(tname, tid, pid)
            cls.task_dict[key] = inst
        return inst

    def __init__(self, tname, tid, pid):
        self.task_name = tname
        self.task_id = tid
        self.parent_id = pid
        self.color = hash_rgb_from_str( str(self) )

    def __repr__(self):
        return "%s[%d/%d]" % (self.task_name, self.task_id, self.parent_id)

class ev_period:
    wait_time = 0.0
    sch_delay = 0.0
    run_time  = 0.0

    def __init__(self, w, s, r):
        self.wait_time = w
        self.sch_delay = s
        self.run_time  = r

    def __repr__(self):
        return "\t".join(["%.3f" % self.wait_time, 
                          "%.3f" % self.sch_delay,
                          "%.3f" % self.run_time])
class ev_callstack:
    # per-class variables
    stackframe_dict= {} 

    # per-instanace variables
    stackframe = ""
    color = (0.0, 0.0, 0.0)

    @classmethod
    def get_instance(cls, cs):
        inst = cls.stackframe_dict.get(cs)
        if inst == None: 
            inst = cls(cs)
            cls.stackframe_dict[cs] = inst
        return inst

    def __init__(self, cs):
        self.stackframe = cs
        self.color = hash_rgb_from_str( str(self) )

    def __repr__(self):
        return self.stackframe

class ev_sched:
    # per-class variables
    ty = ev_type.SCHED
    color =  hash_rgb_from_str( str(ev_type.SCHED) )

    # per-instanace variables
    time   = None
    period = None
    cur_task  = None
    next_task = None 
    callstack = None

    def __init__(self, time, period, cur_task, next_task, callstack):
        self.time = time
        self.period = period
        self.cur_task = cur_task
        self.next_task = next_task
        self.callstack = callstack

    def __repr__(self):
        return "\t".join(["S", str(self.time), str(self.cur_task), str(self.period), 
                          "=>", str(self.next_task), str(self.callstack)])

class ev_idle:
    # per-class variables
    ty = ev_type.IDLE
    color =  hash_rgb_from_str( str(ev_type.IDLE) )

    # per-instanace variables
    time = None
    period = None
    cur_task  = None
    next_task = None 

    def __init__(self, time, period, cur_task, next_task):
        self.time = time
        self.period = period
        self.cur_task = cur_task
        self.next_task = next_task

    def __repr__(self):
        return "\t".join(["I", str(self.time), str(self.cur_task), str(self.period), 
                          "=>", str(self.next_task)])

class ev_mig:
    # per-class variables
    ty = ev_type.MIG
    color =  hash_rgb_from_str( str(ev_type.MIG) )

    # per-instanace variables
    time   = None
    cur_task  = None
    next_task = None 
    to_cpu_id = 0

    def __init__(self, time, cur_task, migrated_task, to_cpu_id):
        self.time = time
        self.cur_task = cur_task
        self.next_task = migrated_task
        self.to_cpu_id = to_cpu_id

    def __repr__(self):
        return "\t".join(["M", str(self.time), str(self.cur_task), 
                          "=>", str(self.next_task)])

class ev_awake:
    # per-class variables
    ty = ev_type.AWAKE
    color =  hash_rgb_from_str( str(ev_type.AWAKE) )

    # per-instanace variables
    time   = None
    cur_task  = None
    next_task = None 

    def __init__(self, time, cur_task, awakened_task):
        self.time = time
        self.cur_task = cur_task
        self.next_task = awakened_task

    def __repr__(self):
        return "\t".join(["A", str(self.time), str(self.cur_task), 
                          "=>", str(self.awakened_task)])

def parse_ev_time(toks):
    time = float(toks[0])
    cpu_id = int(toks[1][1:-1])
    return ev_time(time, cpu_id), toks[2:]
    
def parse_ev_type(toks):
    if toks[0] == "s":
        return ev_type.SCHED, toks[1:]
    elif toks[0] == "i":
        return ev_type.IDLE, toks[1:]
    elif toks[0] == "m":
        return ev_type.MIG, toks[1:]
    else:
        return ev_type.AWAKE, toks

def parse_ev_task(toks):
    if toks[0] == "<idle>" or toks[0] == "swapper": 
        return ev_task.get_instance(toks[0], 0, 0), toks[1:]
    
    tstr = ""
    for i, t in enumerate(toks):
        if t[-1] == "]":
            tstr = tstr + t
            toks = toks[i+1:]
            break
        tstr = tstr + t + " "

    tsk_tok = tstr[:-1].split("[")
    tname = tsk_tok[0]
    tid, pid = 0, 0
    if len(tsk_tok) == 2:
        pid_tok = tsk_tok[1].split("/")
        tid = int(pid_tok[0])
        if len(pid_tok) == 2: 
            pid = int(pid_tok[1])
    return ev_task.get_instance(tname, tid, pid), toks

def parse_ev_period(toks):
    w = float(toks[0])
    s = float(toks[1])
    r = float(toks[2])
    return ev_period(w, s, r), toks[3:]

def parse_ev_callstack(toks):
    stackframe = ' '.join(toks)
    return ev_callstack.get_instance(stackframe), []

def parse_ev_sched(toks, time):
    cur_task, toks = parse_ev_task(toks)
    period, toks = parse_ev_period(toks)
    next_task, toks = parse_ev_task(toks[1:]) # toks[0] should be 'next:'
    callstack, toks = parse_ev_callstack(toks)
    return ev_sched(time, period, cur_task, next_task, callstack)

def parse_ev_idle(toks, time):
    cur_task, toks = parse_ev_task(toks)
    period, toks = parse_ev_period(toks) 
    next_task, toks = parse_ev_task(toks[1:]) # toks[0] should be 'next:'
    return ev_idle(time, period, cur_task, next_task)

def parse_ev_mig(toks, time):
    cur_task, toks = parse_ev_task(toks)
    migrated_task, toks = parse_ev_task(toks[1:])  # toks[0] should be "migrated:"
    to_cpu_id = int(toks[3]) # toks[] = ["cpu", from_cpu_id, "=>", to_cpu_id]
    return ev_mig(time, cur_task, migrated_task, to_cpu_id)

def parse_ev_awake(toks, time):
    cur_task, toks = parse_ev_task(toks)
    awakened_task, toks = parse_ev_task(toks[1:])  # toks[0] should be "awakened:"
    return ev_awake(time, cur_task, awakened_task)

def parse_ev_line(line):
    parsers = {ev_type.SCHED: parse_ev_sched, ev_type.IDLE: parse_ev_idle, 
               ev_type.MIG: parse_ev_mig,     ev_type.AWAKE: parse_ev_awake,}

    toks = line.split()
    if len(toks) == 0:
        return None

    time, toks = parse_ev_time(toks)
    ty, toks = parse_ev_type(toks)
    return parsers[ty](toks, time)

def skip_column_header(f):
    f.readline()
    f.readline()
    f.readline()

def get_log_name(args, kind):
    log = os.path.join(args.outdir,
                       args.log + "-schedmon-" + kind+ "__.log")
    return log

def load_sched_events(f):
    # - header
    skip_column_header(f)

    # - scheduling events
    events = collections.OrderedDict()
    for line in f:
        ev = parse_ev_line(line)
        if ev == None:
            break
        events[ev.time.time] = ev
    return events

def load_schedmon_timehist(args):
    # get a log file name
    log = get_log_name(args, "timehist_full")
    if os.path.isfile(log) == False:
        log = get_log_name(args, "timehist_short")

    # parse the log
    with open(log, "r") as f:
        sched_events = load_sched_events(f)
        # - TODO: Runtime summary
        # - TODO: Terminated tasks:
        # - TODO: Idle stats:
        # - TODO: Overall smmary

    return sched_events

def filter_sched_events(events, filter_fn, filter_data):
    filtered_events = collections.OrderedDict()

    for time, ev in events.items():
        if filter_fn(ev, filter_data) == True:
            filtered_events[time] = ev

    return filtered_events

def reset_plot():
    plt.clf()
    plt.style.use('default')
    plt.rcParams['font.size'] = 7

def get_plot_name(args, plot_name, suffix):
    log = os.path.join(args.outdir,
                       args.log + "-schedinsight-" + plot_name + "." + suffix)
    return log

def plot_event_chart(args, plot_name, events):
    ty_map = {}
    ctask_map = {}
    ntask_map = {}
    cs_map = {}

    # build data for plot
    def append_color(m, c, i):
        if m.get(c) == None:
            m[c] = []
        m[c].append(i)

    for i, (time, ev) in enumerate(events.items()):
        # - type
        append_color(ty_map, ev.color, i)
        append_color(ctask_map, ev.cur_task.color, i)
        append_color(ntask_map, ev.next_task.color, i)
        if ev.ty == ev_type.SCHED: 
            append_color(cs_map, ev.callstack.color, i)
        # TODO: not very useful if there are more than 1000 events

    # plot events
    # - prepare canvas
    reset_plot()
    fig, axs = plt.subplots(nrows=4, ncols=1, figsize=(7, 3.5))

    # - plot type
    def plot_map(ax, m, title):
        ax.tick_params(left = False, right = False , labelleft = False , 
                       labelbottom = False, bottom = False)
        for c, x_data in m.items():
            ax.bar(x_data, [1] * len(x_data), align='edge', width=1, color = c)
        ax.set_ylim(bottom = 0, top = 1)
        ax.set_ylabel(title)

    plot_map(axs[0], ty_map, "event type")
    plot_map(axs[1], ctask_map, "current task")
    plot_map(axs[2], cs_map, "callstack")
    plot_map(axs[3], ntask_map, "next task")

    # - decoration
    axs[0].tick_params(labeltop = True, top = True)
    axs[3].tick_params(labelbottom = True, bottom = True)
    plt.subplots_adjust(hspace = 0)

    # - save to the file
    fig_name = get_plot_name(args, plot_name, "svg")
    plt.savefig(fig_name)


def get_cmd_options(argv):
    parser = argparse.ArgumentParser(
            prog = "schedinsight",
            description = "Report the detailed analysis of scheduliing activities collected by `perf sched record`",)
    parser.add_argument('-o', '--outdir', action='store', required=True,
                        help='output directory') 
    parser.add_argument('-l', '--log', action='store', required=True,
                        help='log file prefix') 
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='do not print result to stdout' ) 
    args = parser.parse_args(argv)
    return args

if __name__ == "__main__":
    args = get_cmd_options(sys.argv[1:])
    events = load_schedmon_timehist(args)

    """
    plot_event_chart(args, "test", events)
    events = filter_sched_events(events, lambda e, d: e.ty == ev_type.IDLE, None)
    for time, ev in events.items():
        print(ev)
    """

