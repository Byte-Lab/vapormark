#!/usr/bin/env python3
import os
import sys
import argparse
import csv
import matplotlib.pyplot as plt
import zlib
import collections
import statistics

def hash_rgb_from_str(s):
    h = zlib.crc32( bytes(s, 'utf-8') )
    r = (h & 0x00FF00) >> 8
    g = (h & 0xFF0000) >> 16
    b = (h & 0x0000FF) >> 0
    return (float(r)/0xFF, float(g)/0xFF, float(b)/0xFF)

def median(l):
    if len(l) == 0:
        return 0.0
    return statistics.median(l)

def average(l):
    if len(l) == 0:
        return 0.0
    return statistics.mean(l)

def aad(l, avg):
    # average absolute deviation: https://en.wikipedia.org/wiki/Average_absolute_deviation
    if len(l) == 0:
        return 0.0
    sum = 0.0
    for v in l:
        sum = sum + abs(avg - v)
    return sum / len(l)

class ev_type:
    SCHED = 0
    IDLE  = 1
    MIG   = 2
    AWAKE = 3

class ev_time:
    time   = 0.0 
    cpu_id = 0

    def __init__(self, t, c):
        self.time = t
        self.cpu_id = c

    def __repr__(self):
        return "\t".join(["%.6f" % self.time, "[%d]" % self.cpu_id])

class task_stat:
    # task
    ev_task = None

    # ev_sched or ev_idle stat
    sched_num = 0

    sched_waits = None
    sched_wait_med = 0.0
    sched_wait_avg = 0.0
    sched_wait_aad = 0.0
    sched_wait_sum = 0.0

    sched_delays = None
    sched_delay_med = 0.0
    sched_delay_avg = 0.0
    sched_delay_aad = 0.0
    sched_delay_sum = 0.0

    sched_runs = None
    sched_run_med = 0.0
    sched_run_avg = 0.0
    sched_run_aad = 0.0
    sched_run_sum = 0.0
    # TODO: sched_ideal_runs = []

    # ev_mig stat
    migrated_num = 0

    # TODO: sched reason
    # - iowait
    # - lock_wait
    # - preemption timeout
    # - poll/epoll
    # - pipe read

    def __init__(self, ev_task):
        self.ev_task = ev_task
        self.sched_num = 0
        self.sched_waits = []
        self.sched_wait_med = 0.0
        self.sched_wait_avg = 0.0
        self.sched_wait_aad = 0.0
        self.sched_wait_sum = 0.0

        self.sched_delays = []
        self.sched_delay_med = 0.0
        self.sched_delay_avg = 0.0
        self.sched_delay_aad = 0.0
        self.sched_delay_sum = 0.0

        self.sched_runs = []
        self.sched_run_med = 0.0
        self.sched_run_avg = 0.0
        self.sched_run_aad = 0.0
        self.sched_run_sum = 0.0

        self.migrated_num = 0

    def analyze_stat(self):
        # ev_sched or ev_idle?
        if self.ev_task.is_idle() == True:
            sched_events = self.ev_task.ctask_ty_events.get(ev_type.IDLE, collections.OrderedDict()) 
        else:
            sched_events = self.ev_task.ctask_ty_events.get(ev_type.SCHED, collections.OrderedDict())

        for time, ev in sched_events.items():
            self.sched_waits.append(ev.period.wait_time)
            self.sched_delays.append(ev.period.sch_delay)
            self.sched_runs.append(ev.period.run_time)

        # ev_sched/ev_idle stat
        self.sched_num = len(sched_events)

        self.sched_wait_med = median(self.sched_waits)
        self.sched_wait_avg = average(self.sched_waits)
        self.sched_wait_aad = aad(self.sched_waits, self.sched_wait_avg)
        self.sched_wait_sum = sum(self.sched_waits)

        self.sched_delay_med = median(self.sched_delays)
        self.sched_delay_avg = average(self.sched_delays)
        self.sched_delay_aad = aad(self.sched_delays, self.sched_delay_avg)
        self.sched_delay_sum = sum(self.sched_delays)

        self.sched_run_med = median(self.sched_runs)
        self.sched_run_avg = average(self.sched_runs)
        self.sched_run_aad = aad(self.sched_runs, self.sched_run_avg)
        self.sched_run_sum = sum(self.sched_runs)

        # ev_mig stat
        migrated_events = self.ev_task.ntask_ty_events.get(ev_type.MIG, [])
        self.migrated_num = len(migrated_events)
  
class ev_task:
    # per-class variables
    task_dict = {} 
    idle_task_name = "<idle>[0/0]"

    # per-instanace variables
    task_name = ""
    task_id   = 0
    parent_id = 0
    color = (0.0, 0.0, 0.0)

    # task indexes to events
    ctask_ty_events = None  # cur_task:ty  -> [events]
    ctask_cs_events = None  # cur_task:cs  -> [events]
    ntask_ty_events = None  # next_task:ty -> [events]

    # task stat
    task_stat = None

    def __init__(self, tname, tid, pid):
        self.task_name = tname
        self.task_id = tid
        self.parent_id = pid
        self.color = hash_rgb_from_str( str(self) )

        self.ctask_ty_events = collections.OrderedDict()
        self.ctask_cs_events = collections.OrderedDict()
        self.ntask_ty_events = collections.OrderedDict()

        self.task_stat = task_stat(self)

    def __repr__(self):
        return "%s[%d/%d]" % (self.task_name, self.task_id, self.parent_id)

    @classmethod
    def get_instance(cls, tname, tid, pid):
        key = '^'.join([tname, str(tid), str(pid)])
        inst = cls.task_dict.get(key)
        if inst == None: 
            inst = cls(tname, tid, pid)
            cls.task_dict[key] = inst
        return inst

    @classmethod
    def analyze_stat(cls):
        for k, t in cls.task_dict.items():
            t.task_stat.analyze_stat()

    def is_idle(self):
        if self.task_id == 0 and self.parent_id == 0 and self.task_name == "<idle>":
            return True
        return False

    def link_ctask(self, ev, cs = None):
        # - cur_task:ty -> [events]
        ty_events = self.ctask_ty_events.get(ev.ty)
        if ty_events == None:
            ty_events = self.ctask_ty_events[ev.ty] = collections.OrderedDict()
        ty_events[ev.time.time] = ev
        # - cur_task:cs -> [events]
        cs_events = self.ctask_cs_events.get(cs)
        if cs_events == None:
            cs_events = self.ctask_cs_events[cs] = collections.OrderedDict()
        cs_events[ev.time.time] = ev
        # - cs -> [ctasks]
        if cs != None:
            cs.link_ctask(self)

    def link_ntask(self, ev):
        # - next_task:ty -> [events]
        ty_events = self.ntask_ty_events.get(ev.ty)
        if ty_events == None:
            ty_events = self.ntask_ty_events[ev.ty] = collections.OrderedDict()
        self.ntask_ty_events[ev.time.time] = ev

class ev_period:
    wait_time = 0.0
    sch_delay = 0.0
    run_time  = 0.0

    def __init__(self, w, s, r):
        self.wait_time = w
        self.sch_delay = s
        self.run_time  = r

    def __repr__(self):
        return "\t".join(["%.3f" % self.wait_time, 
                          "%.3f" % self.sch_delay,
                          "%.3f" % self.run_time])
class ev_callstack:
    # per-class variables
    stackframe_dict= {} 

    # per-instanace variables
    stackframe = ""
    color = (0.0, 0.0, 0.0)

    # callstack to caller tasks
    cs_ctasks = None

    @classmethod
    def get_instance(cls, cs):
        inst = cls.stackframe_dict.get(cs)
        if inst == None: 
            inst = cls(cs)
            cls.stackframe_dict[cs] = inst
        return inst

    def link_ctask(self, ctask):
        self.cs_ctasks.add(ctask)

    def __init__(self, cs):
        self.stackframe = cs
        self.color = hash_rgb_from_str( str(self) )
        self.cs_ctasks = set()

    def __repr__(self):
        return self.stackframe

class ev_sched:
    # per-class variables
    ty = ev_type.SCHED
    color =  hash_rgb_from_str( str(ev_type.SCHED) )

    # per-instanace variables
    time   = None
    period = None
    cur_task  = None
    next_task = None 
    callstack = None

    def __init__(self, time, period, cur_task, next_task, callstack):
        self.time = time
        self.period = period

        self.cur_task = cur_task
        self.callstack = callstack
        self.cur_task.link_ctask(self, self.callstack)

        self.next_task = next_task
        self.next_task.link_ntask(self)

    def __repr__(self):
        return "\t".join(["S", str(self.time), str(self.cur_task), str(self.period), 
                          "=>", str(self.next_task), str(self.callstack)])

class ev_idle:
    # per-class variables
    ty = ev_type.IDLE
    color =  hash_rgb_from_str( str(ev_type.IDLE) )

    # per-instanace variables
    time = None
    period = None
    cur_task  = None
    next_task = None 

    def __init__(self, time, period, cur_task, next_task):
        self.time = time
        self.period = period

        self.cur_task = cur_task
        self.cur_task.link_ctask(self)

        self.next_task = next_task
        self.next_task.link_ntask(self)

    def __repr__(self):
        return "\t".join(["I", str(self.time), str(self.cur_task), str(self.period), 
                          "=>", str(self.next_task)])

class ev_mig:
    # per-class variables
    ty = ev_type.MIG
    color =  hash_rgb_from_str( str(ev_type.MIG) )

    # per-instanace variables
    time   = None
    cur_task  = None
    next_task = None 
    to_cpu_id = 0

    def __init__(self, time, cur_task, migrated_task, to_cpu_id):
        self.time = time
        self.to_cpu_id = to_cpu_id

        self.cur_task = cur_task
        self.cur_task.link_ctask(self)

        self.next_task = migrated_task
        self.next_task.link_ntask(self)

    def __repr__(self):
        return "\t".join(["M", str(self.time), str(self.cur_task), 
                          "=>", str(self.next_task)])

class ev_awake:
    # per-class variables
    ty = ev_type.AWAKE
    color =  hash_rgb_from_str( str(ev_type.AWAKE) )

    # per-instanace variables
    time   = None
    cur_task  = None
    next_task = None 

    def __init__(self, time, cur_task, awakened_task):
        self.time = time

        self.cur_task = cur_task
        self.cur_task.link_ctask(self)

        self.next_task = awakened_task
        self.next_task.link_ntask(self)

    def __repr__(self):
        return "\t".join(["A", str(self.time), str(self.cur_task), 
                          "=>", str(self.awakened_task)])

def parse_ev_time(toks):
    time = float(toks[0])
    cpu_id = int(toks[1][1:-1])
    return ev_time(time, cpu_id), toks[2:]
    
def parse_ev_type(toks):
    if toks[0] == "s":
        return ev_type.SCHED, toks[1:]
    elif toks[0] == "i":
        return ev_type.IDLE, toks[1:]
    elif toks[0] == "m":
        return ev_type.MIG, toks[1:]
    else:
        return ev_type.AWAKE, toks

def parse_ev_task(toks):
    if toks[0] == "<idle>" or toks[0] == "swapper": 
        return ev_task.get_instance(toks[0], 0, 0), toks[1:]
    
    tstr = ""
    for i, t in enumerate(toks):
        if t[-1] == "]":
            tstr = tstr + t
            toks = toks[i+1:]
            break
        tstr = tstr + t + " "

    tsk_tok = tstr[:-1].split("[")
    tname = tsk_tok[0]
    tid, pid = 0, 0
    if len(tsk_tok) == 2:
        pid_tok = tsk_tok[1].split("/")
        tid = int(pid_tok[0])
        if len(pid_tok) == 2: 
            pid = int(pid_tok[1])
    return ev_task.get_instance(tname, tid, pid), toks

def parse_ev_period(toks):
    w = float(toks[0])
    s = float(toks[1])
    r = float(toks[2])
    return ev_period(w, s, r), toks[3:]

def parse_ev_callstack(toks):
    stackframe = ' '.join(toks)
    return ev_callstack.get_instance(stackframe), []

def parse_ev_sched(toks, time):
    cur_task, toks = parse_ev_task(toks)
    period, toks = parse_ev_period(toks)
    next_task, toks = parse_ev_task(toks[1:]) # toks[0] should be 'next:'
    callstack, toks = parse_ev_callstack(toks)
    return ev_sched(time, period, cur_task, next_task, callstack)

def parse_ev_idle(toks, time):
    cur_task, toks = parse_ev_task(toks)
    period, toks = parse_ev_period(toks) 
    next_task, toks = parse_ev_task(toks[1:]) # toks[0] should be 'next:'
    return ev_idle(time, period, cur_task, next_task)

def parse_ev_mig(toks, time):
    cur_task, toks = parse_ev_task(toks)
    migrated_task, toks = parse_ev_task(toks[1:])  # toks[0] should be "migrated:"
    to_cpu_id = int(toks[3]) # toks[] = ["cpu", from_cpu_id, "=>", to_cpu_id]
    return ev_mig(time, cur_task, migrated_task, to_cpu_id)

def parse_ev_awake(toks, time):
    cur_task, toks = parse_ev_task(toks)
    awakened_task, toks = parse_ev_task(toks[1:])  # toks[0] should be "awakened:"
    return ev_awake(time, cur_task, awakened_task)

def parse_ev_line(line):
    parsers = {ev_type.SCHED: parse_ev_sched, ev_type.IDLE: parse_ev_idle, 
               ev_type.MIG: parse_ev_mig,     ev_type.AWAKE: parse_ev_awake,}

    toks = line.split()
    if len(toks) == 0:
        return None

    time, toks = parse_ev_time(toks)
    ty, toks = parse_ev_type(toks)
    return parsers[ty](toks, time)

def skip_column_header(f):
    f.readline()
    f.readline()
    f.readline()

def get_log_name(args, kind):
    log = os.path.join(args.outdir,
                       args.log + "-schedmon-" + kind+ "__.log")
    return log

def parse_sched_events(f):
    # - header
    skip_column_header(f)

    # - scheduling events
    events = collections.OrderedDict()
    for line in f:
        ev = parse_ev_line(line)
        if ev == None:
            break
        events[ev.time.time] = ev
    return events

def parse_schedmon_timehist(args):
    # get a log file name
    log = get_log_name(args, "timehist_full")
    if os.path.isfile(log) == False:
        log = get_log_name(args, "timehist_short")

    # parse the log
    with open(log, "r") as f:
        sched_events = parse_sched_events(f)
        # - TODO: Runtime summary
        # - TODO: Terminated tasks:
        # - TODO: Idle stats:
        # - TODO: Overall smmary

    return sched_events

def analyze_events():
    ev_task.analyze_stat()

def load_schedmon_timehist(args):
    sched_events = parse_schedmon_timehist(args)
    analyze_events()

    return sched_events

def rebuild_indexes(events):
    # TODO
    print("Sorry! Not implemented yet!")
    pass

def filter_sched_events(events, filter_fn, filter_data):
    filtered_events = collections.OrderedDict()

    for time, ev in events.items():
        if filter_fn(ev, filter_data) == True:
            filtered_events[time] = ev
    rebuild_indexes(filtered_events)

    return filtered_events

def reset_plot():
    plt.clf()
    plt.style.use('default')
    plt.rcParams['font.size'] = 7

def get_plot_name(args, plot_name, suffix):
    log = os.path.join(args.outdir,
                       args.log + "-schedinsight-" + plot_name + "." + suffix)
    return log

def plot_event_chart(args, plot_name, events):
    ty_map = {}
    ctask_map = {}
    ntask_map = {}
    cs_map = {}

    # build data for plot
    def append_color(m, c, i):
        if m.get(c) == None:
            m[c] = []
        m[c].append(i)

    for i, (time, ev) in enumerate(events.items()):
        # - type
        append_color(ty_map, ev.color, i)
        append_color(ctask_map, ev.cur_task.color, i)
        append_color(ntask_map, ev.next_task.color, i)
        if ev.ty == ev_type.SCHED: 
            append_color(cs_map, ev.callstack.color, i)
        # TODO: not very useful if there are more than 1000 events
        # TODO: extend the inerface to time range

    # plot events
    # - prepare canvas
    reset_plot()
    fig, axs = plt.subplots(nrows=4, ncols=1, figsize=(7, 3.5))

    # - plot type
    def plot_map(ax, m, title):
        ax.tick_params(left = False, right = False , labelleft = False , 
                       labelbottom = False, bottom = False)
        for c, x_data in m.items():
            ax.bar(x_data, [1] * len(x_data), align='edge', width=1, color = c)
        ax.set_ylim(bottom = 0, top = 1)
        ax.set_ylabel(title)

    plot_map(axs[0], ty_map, "event type")
    plot_map(axs[1], ctask_map, "current task")
    plot_map(axs[2], cs_map, "callstack")
    plot_map(axs[3], ntask_map, "next task")

    # - decoration
    axs[0].tick_params(labeltop = True, top = True)
    axs[3].tick_params(labelbottom = True, bottom = True)
    plt.subplots_adjust(hspace = 0)

    # - save to the file
    fig_name = get_plot_name(args, plot_name, "svg")
    plt.savefig(fig_name)

def analyze_task_stat():
    stat_names = ["task name", "num sched", "num mig" # 0--2
                  "wait time (median)", "wait time (avg)", "wait time (aad)", "wait time (total)", # 3--6
                  "sched delay (median)", "sched delay (avg)", "sched delay (aad)", "sched delay (total)", # 7-10
                  "runtime (median)", "runtime (avg)", "runtime (aad)", "runtime (total)", # 11-14
                  "rank_nsched", "rank_nmig", "rank_runtime", "score", # 15-18
                  ]

    # collect system-wide task stats
    stat_list = []
    for k, t in ev_task.task_dict.items():
        s = t.task_stat

        t_info = [str(t), s.sched_num, s.migrated_num]
        w_stat = [s.sched_wait_med, s.sched_wait_avg, s.sched_wait_aad, s.sched_wait_sum]
        d_stat = [s.sched_delay_med, s.sched_delay_avg, s.sched_delay_aad, s.sched_delay_sum]
        r_stat = [s.sched_run_med, s.sched_run_avg, s.sched_run_aad, s.sched_run_sum]

        stat = t_info + w_stat + d_stat + r_stat
        stat_list.append(stat)

    # calc score
    # - by number of sched
    stat_list.sort(reverse = True, key = lambda x: x[1])
    for i, s in enumerate(stat_list):
        s.append(i) # 15
    # - by number of migration
    stat_list.sort(reverse = True, key = lambda x: x[2])
    for i, s in enumerate(stat_list):
        s.append(i) # 16
    # - by total runtime
    stat_list.sort(reverse = True, key = lambda x: x[14])
    for i, s in enumerate(stat_list):
        s.append(i) # 17
    # - score = rank_nsched**2 + rank_nmig**2 + rank_runtime**2
    for i, s in enumerate(stat_list):
        ns, nm, rt = s[15], s[16], s[17]
        score = ns*ns + nm*nm + rt*rt
        s.append(score) #18

    # soft by score
    stat_list.sort(key = lambda x: x[18])

    return (stat_names, stat_list)

def get_cmd_options(argv):
    parser = argparse.ArgumentParser(
            prog = "schedinsight",
            description = "Report the detailed analysis of scheduliing activities collected by `perf sched record`",)
    parser.add_argument('-o', '--outdir', action='store', required=True,
                        help='output directory') 
    parser.add_argument('-l', '--log', action='store', required=True,
                        help='log file prefix') 
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='do not print result to stdout' ) 
    args = parser.parse_args(argv)
    return args

if __name__ == "__main__":
    args = get_cmd_options(sys.argv[1:])
    events = load_schedmon_timehist(args)
    analyze_task_stat()

    """
    for cs in ev_callstack.stackframe_dict:
        print(cs)

    plot_event_chart(args, "test", events)
    events = filter_sched_events(events, lambda e, d: e.ty == ev_type.IDLE, None)
    for time, ev in events.items():
        print(ev)
    """

    '''
    #### task stat
    sched distibution: violin vs. histogram
    runtime disribution: violon  vs. histogram
    ideal runtime distribution: violin vs. histogram
    wait time distribution
    sched distribution
    migration disribution

        #### top tasks (percentail in sched, runtime, wait time)
        sched distibution: violin vs. histogram
        runtime disribution: violon  vs. histogram
        ideal runtime distribution: violin vs. histogram
        wait time distribution

    #### waiter-waker analyis
       2 distribution
       3 distribution
       or more

    #### shced delay
       scheduling in those ones

    '''


